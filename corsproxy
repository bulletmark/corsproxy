#!venv/bin/python -u
'''
A simple CORS proxy. Reads list of target port=http://server[:targetport]
from the command line, or from your config file.
'''
import argparse
import os
import sys
from pathlib import Path
from typing import Iterable, List, Tuple
from urllib.parse import urlsplit, urlunsplit

import aiohttp
import uvicorn
from multidict import CIMultiDict
from starlette.applications import Starlette
from starlette.middleware import Middleware
from starlette.middleware.cors import CORSMiddleware
from starlette.requests import Request
from starlette.responses import Response
from starlette.routing import Route

try:
    import tomllib
except ModuleNotFoundError:
    import tomli as tomllib

# Get location of optional conf file
CNFFILE = Path(os.getenv('XDG_CONFIG_HOME', '~/.config'),
        Path(sys.argv[0]).stem + '.toml')

SCHEMES = ('http://', 'https://')
BINDHOST = '0.0.0.0'

def parse_targets(targets: List[str]) -> Iterable[Tuple[int, str]]:
    'Check and then yield each port, target in given list'
    ports = set()
    for t in targets:
        if '=' not in t:
            sys.exit(f'{t}: not in port=http://server[:targetport] format.')

        port, target = t.split('=', maxsplit=1)

        try:
            portn = int(port)
        except Exception:
            sys.exit(f'{t}: port {port} must be integer.')

        if not any(target.startswith(s) for s in SCHEMES):
            sys.exit(f'{t}: target must start with {" or ".join(SCHEMES)}')

        if portn in ports:
            sys.exit(f'Listening port {portn} specified more than once.')

        ports.add(portn)
        yield portn, target

# Process command line options
opt = argparse.ArgumentParser(description=__doc__.strip())
opt.add_argument('-d', '--debug', action='store_true',
                 help='enable debug output')
opt.add_argument('-b', '--bind-host',
                 help='bind listening sockets to this host, '
                 f'default="{BINDHOST}"')
opt.add_argument('-c', '--conffile',
                 help=f'alternative configuration file, default="{CNFFILE}"')
opt.add_argument('targets', nargs='*',
                 help='1 or more proxy target servers in format '
                 '"port=http://server[:targetport]" or '
                 '"port=https://server[:targetport]" where "port" is the '
                 'local listening port and "server[:targetport]" is the '
                 'server (and optional target port) to proxy to.')

args = opt.parse_args()

# Read configuration file
if args.conffile:
    conffile = Path(args.conffile)
    if not conffile.exists():
        opt.error(f'Configuration file "{conffile}" does not exist.')
else:
    conffile = CNFFILE.expanduser()

if conffile.exists():
    # Get configuration values
    with conffile.open('rb') as fp:
        conf = tomllib.load(fp)
else:
    conf = {}

bind_host = args.bind_host if args.bind_host is not None else \
        conf.get('bind_host', BINDHOST)

# Read target definitions from file if not defined on command line
targets = args.targets or conf.get('targets')
if not targets:
    sys.exit('No target server mappings defined.')

targets = list(parse_targets(targets))
mytarget = None
session = None

async def get(request: Request) -> Response:
    'Proxy the incoming network request'
    # Allocate session first time
    global session
    if not session:
        session = aiohttp.ClientSession(mytarget)

    # Chop scheme + netloc from URL
    url = urlunsplit(urlsplit(str(request.url))._replace(scheme='', netloc=''))

    method = request.method

    if method == 'GET':
        coroutine = session.get(url, headers=request.headers)
    elif method == 'POST':
        coroutine = session.post(url, headers=request.headers,
                                 data=(await request.body()))
    elif method == 'PUT':
        coroutine = session.put(url, headers=request.headers,
                                 data=(await request.body()))
    elif method == 'PATCH':
        coroutine = session.patch(url, headers=request.headers,
                                 data=(await request.body()))
    elif method == 'DELETE':
        coroutine = session.delete(url, headers=request.headers)
    elif method == 'HEAD':
        coroutine = session.head(url, headers=request.headers)
    else:
        return Response(f'Unsupported HTML method "{method}"', 501)

    async with coroutine as response:
        # Some servers have blank chars on end of key values which
        # Starlette does not like
        headers = CIMultiDict((k, v.strip())
                              for k, v in response.headers.items())
        return Response((await response.text()), response.status, headers)

# Set routes and middleware
routes = [Route('/{path:path}', get, methods=('GET', 'POST', 'PUT',
                                              'PATCH', 'DELETE', 'HEAD'))]
middleware = [Middleware(CORSMiddleware, allow_origins=['*'],
                        allow_methods=['*'], allow_headers=['*'])]

# Create the app instance
app = Starlette(debug=args.debug, routes=routes, middleware=middleware)

def run(port: int, target: str) -> None:
    'Runs in a thread, one for each target'
    global mytarget
    mytarget = target
    bhost = f'[{bind_host}]' if ':' in bind_host else bind_host
    print(f'Starting proxy for http://{bhost}:{port} -> {target}')
    log_level = 'debug' if args.debug else 'error'
    uvicorn.run(app, host=bind_host, port=port, log_level=log_level,
                server_header=False, date_header=False)

# Just run in same process if we only have a single proxy service
# configured. Otherwise create and start a process for each service.
if len(targets) == 1:
    run(*targets[0])
else:
    import multiprocessing
    for t in targets:
        multiprocessing.Process(target=run, args=(*t,)).start()

    for p in multiprocessing.active_children():
        p.join()
