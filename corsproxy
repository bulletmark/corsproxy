#!venv/bin/python -u
'''
A simple CORS proxy. Reads list of target server mappings from the
command line, or from your config file. Target server mappings are of
the form "[host:]port=http://server[:targetport]" or
"[host:]port=https://server[:targetport]" where "port" is the local
listening port and "server[:targetport]" is the server (and optional
target port) to proxy to. The default host address to listen on for a
port is '0.0.0.0' to allow all IPv4 connections but you can specify an
alternate host address for each server mapping, e.g. '127.0.0.1' to
limit to local IPv4 connections, or '[::]' for all IPv6 connections, or
'[::1]' to limit to local IPv6 connections, or any specific IPv4 or IPv6
address to limit to that interface. E.g. to listen all IPv4 and IPv6
addresses and forward to same IPv4 server define 2 mappings:
"0.0.0.0:8000=http://192.168.1.1" "[::]:8000=http://192.168.1.1".
'''
import argparse
import os
import re
import sys
from collections import defaultdict
from pathlib import Path
from typing import Iterable, List, Tuple
from urllib.parse import urlsplit, urlunsplit

import aiohttp
import uvicorn
from multidict import CIMultiDict
from starlette.applications import Starlette
from starlette.middleware import Middleware
from starlette.middleware.cors import CORSMiddleware
from starlette.requests import Request
from starlette.responses import Response
from starlette.routing import Route

try:
    import tomllib
except ModuleNotFoundError:
    import tomli as tomllib  # type:ignore

# Get location of optional conf file
CNFFILE = Path(os.getenv('XDG_CONFIG_HOME', '~/.config'),
        Path(sys.argv[0]).stem + '.toml')

SCHEMES = ('http://', 'https://')
DEFHOST = '0.0.0.0'

def parse_targets(targets: List[str]) -> Iterable[Tuple[str, int, str]]:
    'Check and then yield each host, port, target in given list'
    ports = defaultdict(set)
    for t in targets:
        if '=' not in t:
            sys.exit(f'{t}: not in '
                     '[host:]port=http://server[:targetport] format.')

        port, target = t.split('=', maxsplit=1)

        host = DEFHOST
        if ':' in port:
            lhost, port = port.rsplit(':', maxsplit=1)

            # Handle IPv6 addresses enclosed in "[addr]"
            if lhost and lhost != '*':
                host6 = re.search('\[(.+)\]', lhost)
                host = host6.group(1) if host6 else lhost

        try:
            portn = int(port)
        except Exception:
            sys.exit(f'{t}: port {port} must be integer.')

        if not any(target.startswith(s) for s in SCHEMES):
            sys.exit(f'{t}: target must start with {" or ".join(SCHEMES)}')

        if portn in ports.get(host, {}):
            sys.exit(f'Listening port {portn} specified more than once.')

        ports[host].add(portn)
        yield host, portn, target

# Process command line options
opt = argparse.ArgumentParser(description=__doc__.strip())
opt.add_argument('-d', '--debug', action='store_true',
                 help='enable debug output')
opt.add_argument('-c', '--conffile',
                 help=f'alternative configuration file, default="{CNFFILE}"')
opt.add_argument('targets', nargs='*',
                 help='1 or more proxy target server mappings')

args = opt.parse_args()

# Read configuration file
if args.conffile:
    conffile = Path(args.conffile)
    if not conffile.exists():
        opt.error(f'Configuration file "{conffile}" does not exist.')
else:
    conffile = CNFFILE.expanduser()

if conffile.exists():
    # Get configuration values
    with conffile.open('rb') as fp:
        conf = tomllib.load(fp)
else:
    conf = {}

# Read target definitions from file if not defined on command line
targets = args.targets or conf.get('targets')
if not targets:
    sys.exit('No target server mappings defined.')

targets = list(parse_targets(targets))
mytarget = None
session = None

async def get(request: Request) -> Response:
    'Proxy the incoming network request'
    # Allocate session first time
    global session
    if not session:
        session = aiohttp.ClientSession(mytarget)

    # Chop scheme + netloc from URL
    url = urlunsplit(urlsplit(str(request.url))._replace(scheme='', netloc=''))

    method = request.method

    if method == 'GET':
        coroutine = session.get(url, headers=request.headers)
    elif method == 'POST':
        coroutine = session.post(url, headers=request.headers,
                                 data=(await request.body()))
    elif method == 'PUT':
        coroutine = session.put(url, headers=request.headers,
                                 data=(await request.body()))
    elif method == 'PATCH':
        coroutine = session.patch(url, headers=request.headers,
                                 data=(await request.body()))
    elif method == 'DELETE':
        coroutine = session.delete(url, headers=request.headers)
    elif method == 'HEAD':
        coroutine = session.head(url, headers=request.headers)
    else:
        return Response(f'Unsupported HTML method "{method}"', 501)

    async with coroutine as response:
        # Some servers have blank chars on end of key values which
        # Starlette does not like
        headers = CIMultiDict((k, v.strip())
                              for k, v in response.headers.items())
        return Response((await response.text()), response.status, headers)

# Set routes and middleware
routes = [Route('/{path:path}', get, methods=('GET', 'POST', 'PUT',
                                              'PATCH', 'DELETE', 'HEAD'))]
middleware = [Middleware(CORSMiddleware, allow_origins=['*'],
                        allow_methods=['*'], allow_headers=['*'])]

# Create the app instance
app = Starlette(debug=args.debug, routes=routes, middleware=middleware)

def run(host:str, port: int, target: str) -> None:
    'Runs in a thread, one for each target'
    global mytarget
    mytarget = target
    phost = f'[{host}]' if ':' in host else host
    print(f'Starting proxy for http://{phost}:{port} -> {target}')
    log_level = 'debug' if args.debug else 'error'
    uvicorn.run(app, host=host, port=port, log_level=log_level,
                server_header=False, date_header=False)

# Just run in same process if we only have a single proxy service
# configured. Otherwise create and start a process for each service.
if len(targets) == 1:
    run(*targets[0])
else:
    import multiprocessing
    for t in targets:
        multiprocessing.Process(target=run, args=(*t,)).start()

    for p in multiprocessing.active_children():
        p.join()
